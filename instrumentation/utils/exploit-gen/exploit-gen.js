/**
 * CLI Program that takes as an input the config file of a test and a failing
 * model and generates a new concrete config file which can be used to 
 * instrument the source file for an exploit.
 */


/**
 * Requires
 */
const yargs = require("yargs");
const fs = require("fs");
const constants = require("./constants");

 /**
 * Command line interface
 */
const argv = yargs
	.option("models", {
		alias: "m",
		description: "JSON failing models file",
		demandOption: true,
		type: "string"
	})
	.option("config", {
		alias: "c",
		description: "Config file",
		demandOption: true,
		type: "string"
	})
	.option("output-prefix", {
		alias: "o",
		description: "Output file prefix",
		demandOption: true,
		type: "string",
	})
	.usage("Usage: $0 -i [filepath]")
	.help()
	.alias("help", "h").argv;

/***************     Step 1 - read models and config files     ****************/

try {
	var data = fs.readFileSync(argv.models, "utf-8");
	var models = JSON.parse(data);
	data = fs.readFileSync(argv.config, "utf-8");
	var config = JSON.parse(data);
} catch (ex) {
	console.log(ex.toString())
}


/********     Step 2 - replace symbolic types for concrete values     *********/

function replace_defaults(v) {
	switch(v.type) {
		case "Str":
			return {var: v.var, val: constants.default_prop_string};
		case "Num":
			return {var: v.var, val: constants.default_number};
		case "Bool":
			return {var: v.var, val: constants.default_bool};
		default:
			throw new Error(`Not a standard type for ${v.var}`);
	}
}

function replace_symb_var(conf, v) {
	var x = v.var.split("___")[0].split('__');
	var obj = conf.vars.find((e) => e.name === x[0]);
	while ((x = x.slice(1)) != []) {
		if (obj.type === "object") {
			obj = conf.properties.find((e) => e.name === x[0]);
		} else if (obj.type === "array") {
			var obj2 = obj.spec_elem.find((e) => e.index === x[0]);
			if(!obj2) {
				obj.spec_elem.append({index: x[0], type: "concrete", value: v.val})
				return;
			} else {
				obj = obj2;
			}
		} else {
			throw new Error('The model does not correspond to the config');
		}
	}
	obj.type = "concrete";
	obj.value = v.val;
	return;
}

function replace_symbs(v) {
	switch(v.type) {
		case "object":
			for(sub in v.param) {
				replace_symbs(sub);
			}
			return;
		case "array":
			for(sub in v.spec_elem) {
				replace_symbs(sub);
			}
			replace_symbs(v.def_element);
			return;
		case "symbolic":
			v.type = "concrete";
			v.value = constants.default_symbolic;
			return;
	}
}

function generate_exploit(conf, mod) {
	var ret = JSON.parse(JSON.stringify(conf));
	for(var v in mod.fail_model) {
		replace_symb_var(ret, v);
	}
	for(var v in mod.typ_env) {
		if(!mod.fail_model.some((e) => e.var === v.var)) {
			v = replace_defaults(v);
			replace_symb_var(ret, v);
		}
	}
	for(var v in ret.vars){
		replace_symbs(v);
	}
	return ret;
}

for (var mod in models) {
	if (constants.expl_models.includes(mod.assert_arg)) {
		mod.exploit = generate_exploit(config, mod);
	};
}

/************************        Step 3 - output        ***********************/
