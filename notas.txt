--------------------------------------------------------------------
Reunião 18/03
Dúvidas:
  - Todos os packages podem acabar por estar também no dataset de aplicações. O que é que caracterizamos só como packages e como apps? packages criados são para benchmarks e verdadeiras são para ultimo dataset
  - Preferível ter tudo num container para aceder pelo localhost? não
  - O que fazer agora?

Durante:
comprar domain (dominios.pt) e usar letsEncrypt
entry point e sinks

-----------------------------------------------------------------------
Reunião 25/03
Dúvidas:
  - Consideramos como sink o request ou quando damos log do req? req
  - axios sink.
  - osm-static-maps ssrf não está resolvido
  - fuxa não tem patch por isso 1.2.4 ainda é vuln
  - ssrf-agent não está resolvido
  - ssrf-agent não tem sink porque isto é má validação que resulta em SSRF
  - jsreport ainda é vulneravel

Durante:
 - ngrok
 - quando tenho app guardar as 2 sources (app e pac) e 2 sinks; function call dentro da app;
 - experimentar versoes atuais osm-static-maps (4.2.0)

-----------------------------------------------------------------------
Reunião 01/04
Dúvidas:
  - osm-static-maps ssrf não está resolvido no 3.10.1 mas 3.11.0 o download não funciona
  - jsreport ainda é vulneravel

Durante:
  

-----------------------------------------------------------------------
Reunião 08/04
Dúvidas:
  - desmotivado
  - o que fazer a seguir?

Durante:
  - 1ºpasso:
    - fazer modulos que deem flag às queries do graphjs (injection)
    - fazer modulos que não deem flag no graphjs (perceber queries) (injection)
  2º passo:
    - colocar sinks e sources ssrf no config
    - fazer query para ssrf básica ()
    - fazer modulo para bater na ssrf basica
    - ir incrementando a query
  3º passo:
    - passar vuln estudadas para modulo 
    - ver se query dá flag ao modulo

-----------------------------------------------------------------------
Reunião 24/04
Dúvidas:
    - que sources e sinks posso colocar?
    - manter query de injection inicialmente ou fazer já uma coisa elaborada?
  
Durante:
  - fazer novas classes para nova query, baseada na injection (alterar sinks e sources)
  - correr module basico com axios ou http

-----------------------------------------------------------------------
Reunião 08/05
Dúvidas:
    - no folder problems temos exemplos em que não deteta no mesmo file mas deteta em files diff, e acho que devia detetar (ping guilherme)
    - deteta vuln no intra_injection/not_flagged/input/case2 quando não devia detetar (normal)
    - já tenho alguns exemplos feitos para ssrf (2 vulns diff no unidici)
    - há casos em que não só é necessario um sink como também uma options especifica
    - preciso do dataset anotado porque não sei qual é a norma para processar multiplos files
    - caso da maquina que o stor deu

-----------------------------------------------------------------------

Reunião 15/05
Dúvidas:
    - axios (o problema é na sanitização)
    - há um teste que verifica secure_return_caller e de facto não há vuln reportadas mas quando são files diff deteta
    - queria a lista anotada para saber como está a estrutura dos modulos 
    - num dos ultimos commits eles colocaram uma opção para analisar todo o dataset (vulcan, secbench, etc), mas não colocaram no github os tais datasets


Durante:
    - marcar como vulnerabilidade e passou numa potencial sanitização
    - mandar mail a Mafalda sobre datasets do Graphjs (como funcionam a função de analisar datasets)
    - falar com guilherme sobre exemplos de FP
-----------------------------------------------------------------------

Reunião 22/05
Problemas:
    - leitura de pacotes no config.json:
        - quando usamos um require no pacote e o resultado é uma função (index1) temos 2 problemas:
            - não é considerada função mas sim alias e por isso não é detetada
            - quando utilizada como parametro x.x não é detetada
        - 
Dúvidas:
    
vulnerabilidades:
    - axios: erro no esprisma parsing
    - cors-proxy: não consigo identificar o fetch como sink
    - link-preview-js: funciona com o package certo
    - node-pdf-generator: mesmo problema do fetch
    - phantom-seo: funciona mas damos flag a todas as funcoes open
    - ssrf-req-filter: funciona mas damos flag a todas as funcoes call (nem sei se é aqui que acontece o request ou no socket.on)
    - svg2png: não deteta provalmente por não detetar source to sink
    - undici: erro no esprima parsing


Durante:
    - verificar o que se passa no graph do countercase e nao passa no case:
        - ENCONTREI PROBLEMA: no countercase há uma veri que é validada porque o flow vai para fora do ficheiro e bate no undefined do set_this_undefined_calls, no entanto no case não é validada porque o data flow não vai para outro file nem conta como return
        para mostrar ao stor ver case normal como não é validade, é validada no countercase e nã sendo validada no case1 esse conta como return e aparece validada pelor return
    - ver se o erro origina dos node_module/ (verificar se isto acontece por ir buscar typescript):
        - VERDADE (quando o módulo é feito em typescript)
    - como é que o parser:
        -tenho alguma ideia
    - ver datasets e como correr datasets
-----------------------------------------------------------------------
Reunião 29/05
Problemas:

Dúvidas:



Durante:

-----------------------------------------------------------------------
Reunião 05/06
vulnerabilidades:
    - axios: erro no esprisma parsing
    - cors-proxy: não consigo identificar data flow mas consigo identificar fetch
    - link-preview-js: funciona com o package certo
    - node-pdf-generator: funciona mas damos flag a todas as funcoes htmlToPdf
    - phantom-seo: funciona mas damos flag a todas as funcoes open
    - ssrf-req-filter: funciona mas damos flag a todas as funcoes call (nem sei se é aqui que acontece o request ou no socket.on)
    - svg2png: não deteta provalmente por não detetar source to sink
    - undici: erro no esprima parsing

Problemas:
  - quando lidamos com nested functions, anonymous functions e higher-order exports precisamos de dar export a todas as funções ou corremos o risco do analiser não ver a função
  - não deteta se tentarmos dar require de uma função e.g, (apenas para ficheiros não modulos)
  const { helper } = require('./helper')
  mas sim, se dermos require a um file e depois usarmos uma função
  const helper = require('./helper')
  - não deteta quando está (wrapped inside closure, hidden inside nested return function)
  Basicamente o que isto quer dizer é que não deteta quando uma função retorna outra e só depois podemos usar esse return para chamar a função que queremos

Informação sobre parsing de modulos:
  - não necessitamos de ter o node_modules localmente para detetar
  - passa pelo modulo se o tivermos localmente (não sei se é necessário)



Durante:
  - mudar parser
  - quando temos anonymous exportada dar-lhe o nome do require dela no chamante

-----------------------------------------------------------------------
Reunião 12/06


Durante:
  - mudar express_app para ter funçoes normais em que os param são o metodo do route; req, res (com o nome do /)
  - ver parsing do primeiro problema e da factory function

-----------------------------------------------------------------------
Reunião 20/06

  Trabalho: 
    - Consegui detetar o meu exemplo mas não o módulo por causa do acrescimo de dificuldade (muito dificil fazer o tracing the params sendo que não há nenhum param ligado à chamada do middleware)
    - Consegui detetar o { g }
    - Consegui detetar return {data: userInput};
    - Consegui dar fix ao FP do returnLiteral
    - Consegui detetar a app mas tenho problema no await

  Dúvidas: 
    - await 
    - factory function no appToModule
    - papel que o colega lhe vai dar
    - criar outra key para login na vm


  Durante:
    - ver guilherme
    - tirar async
    - ver o que estoura appToModule
    - ver cors com neo4j queries
    - factoryFunction vai ter de ver as 2 func
    - ver caso em que usa param do createMidd

-----------------------------------------------------------------------

Reunião 1/07

  Trabalho: 
    - falei com o guilherme, ele testou com a ae e usou os datasets que lá estavam mas somou os TFP ao TFP
    - já tenho proProcessor
    - o erro no EPIPE vem de gerar o grafo

  Dúvidas: 
    


  Durante:
    - ver cors com neo4j queries
    - factoryFunction vai ter de ver as 2 func
    - ver caso em que usa param do createMidd
    - criar app com modulo testado pelo guilherme para testar
    - middleware podem ser diff em diff metodos
    - testar processed app (possivel alteracao para next ser a proxima funcao)
    - verificar o FP que saiu

    - res.redirect é uma chamada a outro endpoint

-----------------------------------------------------------------------

Reunião 17/07

  Trabalho: 
    - middleware diff em diff metodos
    - processed app tem agora o CFG funcional
    - criar app com modulo testado pelo guilherme para testar

  Dúvidas: 
    - Para criar o processed_output dentro do output tenho de colocar todos os outros ficheiros dentro do processed para o grafo ser feito, ora isto leva tempo
        - 2 soluções:
            - criar o processed dentro do input e assim não tenho de copiar ficheiros
            - copiar apenas os ficheiros required pelos ficheiros de forma recursiva (mais dificil)


  Durante:
    - Resolver middleware diff nos diff metodos
    - Criar uma app que usa os modulos do processed
    - Investigar SSRF dentro dos template com data (usar render como require em que os temp são função e os )
    - fazer um mapa das linhas onde as sinks se encontram no ficheiro original para o processed ficheiro 

-----------------------------------------------------------------------

Reunião 24/07

  Trabalho: 
    - tudo do preProcesser
    - criar app que usa modulos do processed
    - já processo app2module e depois module2app e funciona
    - passei de esprima para espree para conseguir parsar novas versões do ECMAS
    - depois de alguns tweeks ao parser já não tenho erros
    - consigo agora parsar todo o tipo de files porque excluo .ts
    

  Problemas:
    - quando usamos um middleware e é o middleware que tem a vuln temos o mesmo problema do cors_proxy
    - app.use middleware
    
  Durante:
    - Usar async await no processed
    - flag para criar app a usar modulo
    - tornar app.use para todas as vuln
    - testar o pq de phantom-seo não estar a detetar
    - testar apps do dataset
    - lista de todas as alterações que fiz ao graph.js

-----------------------------------------------------------------------

Reunião 31/07

  Trabalho: 
    - remover chaining operator porque com o espree tenho um novo tipo na AST
    - adicionei handling de await no parser (bastou ignorar o await e adicionar na mesma o Variable Assignment)
    - flag para criar app a usar modulo
    - deteto phantom porque consegui modificar a maneira como guardamos os exported_object dos modulos (quando damos require de um node_module damos apenas ao nome do modulo e não ao index file e quando guardamos guardamos como {nome_do_modulo}/index.js )
      - agora crio um mapa para mapear o main file de todos os node_modules para depois o ir buscar
    - passei app.use() para chained middleware

  Falta:
    - Passar app.use quando é especifico para um route
    - parsar os metadados dos sinks e sources
    - encontrar falso positivo
    - testar o dataset
    - começar graphjs de novo e ir adicionando coisas e testando para ter uma lista de alterações correta e testes que o comprovem

  Durante: 
    - verificar chain operator
    - verificar flag silent
    - diferença entre espree e esprima

    -----------------------------------------------------------------------

Reunião 01/09

  Trabalho: 
    - lista de todas as alterações que fiz ao graph.js
    - escrita sobre alterações
    - alterar o parser.ts no graphjs_new (tenho alterações do graphjs quando estava a verificar as mudanças)
    - testar se await sem variable assignment resulta (depois de mudanças resulta)
    - app.use individual
    - verificar flag silent
    - resolvi caso em que colocamos num sink diretamente num objeto (testar funcEvalObj e funcEvalConstObj)
    - tentei resolver caso html-pdf-chrome

  Falta:
    - verifica melhor o FP do helper.g 
    - verificar chain operator
    - awaiter (muito dificil)
    - parsar os metadados dos sinks e dos sources (preProcesser.py)
    - escrever a partir do finding await
    - rever dataset
    - recomeçar no dataset onde primeiro vais rever os sinks todos e os PoC (isto depende de como está a escrita)
    - perguntar ao andré sobre await
    - normObj por causa do data = {input2: {input1: userInput}}
    - perguntar ao chat sobre data.input.input = userInput

  Dúvida:
    - explico com exemplos simplificados mesmo tendo encontrado os erros por causa das app

  Durante: 

    
  Ideias Escrita:
    - antes da implementação escrever uma história por ordem cronologica dos meus findings, (primeiro testei as queries deles, depois as minhas e depois o dataset) e que mudanças foram surgindo com isso
      - na implementação escrever por secções ( overall fixes/features or ssrf fixes/features) e se calhar separar ainda no preProcesser
      - outra ideia que se pode fazer é separar por módulos como fizemos no PIC, preProcesser, modulo de criação de MDG e modulo de deteção
    - houve muitos fixes que vieram por causa dos exemplos do dataser, simplifico e digo que vi os exemplos e criei exemplos mais simples ou uso os exemplos do dataset para lhes explicar?
    - sinto que aqui podemos simplificar mas depois retirar alguns exemplos para explicar que as mudanças que fiz fizeram com que detetasse


  exemplos queries -> exemplos modulos dataset -> preProcesser -> exemplos app dataset

  Dataset:
    axios: não deteta sink do modulo (rever)
    cors: não
    directus: sem PoC no dataset
    ftp-srv: PoC não está acabado
    fuxa: sem PoC no dataset
    ghost: sem PoC no dataset
    google-translate-api-browser: sem sink no modulo
    html-pdf-chrome: não consigo detetar por causa de awaiter
    jsreport: sem PoC 
    kibana: sem PoC
    kityminder: sem PoC
    link-preview: não consigo detetar por causa de awaiter
    node-pdf-app: não consigo detetar por causa do args.push() :(
    phantomjs-seo: consigo huhuhuhu, rever parentesis que lixa o phantomjs
    rendertron: não tenho PoC
    request: rever
    




final:
 1. dataset (tudo anotado)
 2. parser que pega em app e converte em modulo (e passar depois de modulo para ser usado em app)+ metadata linhas
 3. parsar todas as apps do dataset em modulos
 4. correr o graphjs nos modulos
 5. validar que as vulns são corretas
 6. (opcional) mostrar equivalencia funcional





TODO
- entry point e sinks
- ver os que não fiz
- passar os que não têm docker para docker

REVER:
- ssrf-agent não está resolvido
- ssrf-agent não tem sink porque isto é má validação que resulta em SSRF

