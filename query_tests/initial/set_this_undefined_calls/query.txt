MATCH 
                            (arg:PDG_OBJECT)
                                -[arg_edge:PDG]
                                    ->(call:PDG_CALL)
             
                        WHERE 
                            arg_edge.IdentifierName = "this" OR arg_edge.IdentifierName = "undefined"
             
                        RETURN arg.Id, arg.IdentifierName, arg_edge.RelationType, arg_edge.IdentifierName, call.Id, call.IdentifierName;


Objective:

flag as valid (may have data flow) relations between args and function calls (exported)

flows de args entre modulos








MATCH
			(func:VariableDeclarator)
				-[ref_edge:REF]
					->(param:PDG_OBJECT)

OPTIONAL MATCH (param)
					-[edges:PDG*1..]
							->(sink:TAINT_SINK)
				
				WHERE
				ref_edge.RelationType = "param" AND
				ALL(
					edge in edges WHERE
					NOT edge.RelationType = "ARG" OR
					edge.valid = true
				)

OPTIONAL MATCH
					(param)-[edge:PDG]->(prop:PDG_OBJECT)<-[edges1:PDG*1..]-(obj:PDG_OBJECT)-[edge2:PDG]->(sink:TAINT_SINK)

					WHERE
						edge.RelationType = "DEP" AND
						ALL(
						edge1 in edges1 WHERE
						edge1.RelationType in ["SO","NV"] ) AND
						edge2.RelationType = "DEP"

						
			(sink_cfg)
				-[:SINK]
					->(sink),

			(sink_cfg)
				-[:AST]
					->(sink_ast)

			
			RETURN *




MATCH
    (func:VariableDeclarator)
        -[ref_edge:REF]->(param:PDG_OBJECT)
WHERE
    ref_edge.RelationType = "param"

OPTIONAL MATCH 
    // Case 1: direct taint flow
    (param)-[edges:PDG*1..]->(sink:TAINT_SINK),

(sink_cfg)-[:SINK]->(sink),
(sink_cfg)-[:AST]->(sink_ast)
WHERE
    ALL(edge IN edges WHERE NOT edge.RelationType = "ARG" OR edge.valid = true)

OPTIONAL MATCH
    // Case 2: indirect via DEP + SO/NV + DEP
    (param)-[edge:PDG]->(prop:PDG_OBJECT)
	<-[edges1:PDG*1..]-(obj:PDG_OBJECT)
	-[edge2:PDG]->(sink:TAINT_SINK),

(sink_cfg)-[:SINK]->(sink),
(sink_cfg)-[:AST]->(sink_ast)

	WHERE
		edge.RelationType = "DEP" AND
		ALL(
		edge1 in edges1 WHERE
		edge1.RelationType in ["SO","NV"] ) AND
		edge2.RelationType = "DEP"

MATCH
    (sink_cfg)-[:SINK]->(sink),
    (sink_cfg)-[:AST]->(sink_ast)

RETURN DISTINCT func, param, sink, sink_cfg, sink_ast


MATCH
  (func:VariableDeclarator)-[ref_edge:REF]->(param:PDG_OBJECT)
WHERE
  ref_edge.RelationType = "param"

OPTIONAL MATCH
  (param)-[edges:PDG*1..]->(sink_direct:TAINT_SINK)
WHERE
  ALL(edge IN edges WHERE NOT edge.RelationType = "ARG" OR edge.valid = true)

OPTIONAL MATCH
  (param)-[edge:PDG]->(prop:PDG_OBJECT)
         <-[edges1:PDG*1..]-(obj:PDG_OBJECT)
         -[edge2:PDG]->(sink_indirect:TAINT_SINK)
WHERE
		edge.RelationType = "DEP" AND
		ALL(
		edge1 in edges1 WHERE
		edge1.RelationType in ["SO","NV"] ) AND
		edge2.RelationType = "DEP"

WITH func, param, [sink_direct, sink_indirect] AS sinks
UNWIND sinks AS sink
WITH func, param, sink
WHERE sink IS NOT NULL

MATCH
  (sink_cfg)-[:SINK]->(sink),
  (sink_cfg)-[:AST]->(sink_ast)

RETURN DISTINCT func, param, sink, sink_cfg, sink_ast;


